<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Kunst, Bezierkurven auf nicht iterative Weise zu berechnen</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="gliederung.html">Gliederung</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_1/WasSindBezierkurven.html"><strong aria-hidden="true">1.</strong> Einführung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/WasSindBezierkurven.html"><strong aria-hidden="true">1.1.</strong> Was sind Bezierkurven</a></li><li class="chapter-item expanded "><a href="chapter_1/WoFindetManBezierkurven.html"><strong aria-hidden="true">1.2.</strong> Wo findet man Bezierkurven</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Zeichnen von Bezierkurven</a></li><li class="chapter-item expanded "><a href="chapter_3/Anwendung.html"><strong aria-hidden="true">3.</strong> Anwendung von bezierkurven beim Erstellen von Software</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/Anwendung.html"><strong aria-hidden="true">3.1.</strong> Anwendung</a></li><li class="chapter-item expanded "><a href="chapter_3/IneffizienzUndSchwierigkeitenInDerPraxis.html"><strong aria-hidden="true">3.2.</strong> Ineffizienz und Schwierigkeiten in der Praxis</a></li><li class="chapter-item expanded "><a href="chapter_3/MathematischerLoesungsansatz.html"><strong aria-hidden="true">3.3.</strong> Mathematischer Lösungsansatz</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Zussamenfassung</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="links.html"><strong aria-hidden="true">5.1.</strong> Literaturangabe</a></li><li class="chapter-item expanded "><a href="chapter_5/WeitereLinks.html"><strong aria-hidden="true">5.2.</strong> Weitere Links</a></li><li class="chapter-item expanded "><a href="chapter_5/Code.html"><strong aria-hidden="true">5.3.</strong> Code</a></li><li class="chapter-item expanded "><a href="chapter_5/Demos.html"><strong aria-hidden="true">5.4.</strong> Demos</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Die Kunst, Bezierkurven auf nicht iterative Weise zu berechnen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="gliederung"><a class="header" href="#gliederung">Gliederung</a></h2>
<h3 id="1-einführung"><a class="header" href="#1-einführung"><a href="./chapter_1/WasSindBezierkurven.html">1. Einführung</a></a></h3>
<p>    <a href="chapter_1/WasSindBezierkurven.html">1.1 Was sind Bezierkurven</a> <br />
    <a href="chapter_1/WoFindetManBezierkurven.html">1.2 Wo findet man Bezierkurven</a></p>
<h3 id="2-zeichnen-von-bezierkurven"><a class="header" href="#2-zeichnen-von-bezierkurven"><a href="chapter_2.html">2. Zeichnen von Bezierkurven</a></a></h3>
<p>    <a href="chapter_2.html#21-nutzung-des-de-casteljaus-algorithmus">2.1 Nutzung des De Casteljau's Algorithmus</a></p>
<h3 id="3-anwendung-von-bezierkurven-beim-erstellen-von-software"><a class="header" href="#3-anwendung-von-bezierkurven-beim-erstellen-von-software"><a href="chapter_3/Anwendung.html">3. Anwendung von Bezierkurven beim Erstellen von Software</a></a></h3>
<p>    <a href="chapter_3/Anwendung.html">3.1 Anwendung</a> <br />
    <a href="chapter_3/IneffizienzUndSchwierigkeitenInDerPraxis.html">3.2 Ineffizienz und Schwierigkeiten in der Praxis</a> <br />
    <a href="chapter_3/MathematischerLoesungsansatz.html">3.3 Mathematischer Lösungsansatz</a> </p>
<h3 id="4-zussamenfassung"><a class="header" href="#4-zussamenfassung"><a href="chapter_4.html">4. Zussamenfassung</a></a></h3>
<h3 id="5-anhang"><a class="header" href="#5-anhang"><a href="chapter_5.html">5. Anhang</a></a></h3>
<p>    <a href="./links.html">5.1 Literaturangabe</a> <br />
    <a href="chapter_5/WeitereLinks.html">5.2 Weitere Links</a> <br />
    <a href="chapter_5/Code.html">5.3 Code</a> <br />
    <a href="chapter_5/Demos.html">5.4 Demos</a></p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="11-was-sind-bezierkurven"><a class="header" href="#11-was-sind-bezierkurven">1.1 Was sind Bezierkurven</a></h3>
<p>Der französische Ingenieur Pierre Étienne Bézier<a href="chapter_1/../links.html#a1">\(^{A1}\)</a>, geboren 1910 in Paris, entwickelte in den 60er Jahren eine Gestaltungsmöglichkeit von Karosserieformen für seinen damaligen Arbeitgeber Renault. Seit 1968 ist sein System zur &quot;Freiform Kurven und Oberflächen Design&quot; (&quot;interactive free-form curve and surface design and 3D milling for manufactoring clay models and masters&quot;<a href="chapter_1/../links.html#a2">\(^{A2}\)</a>) bei Renault in Nutzung.</p>
<p>Auch der französische Mathematiker Paul de Faget de Casteljau, geboren 1930, beschäftigte sich im 20ten Jahrhundert mit der Modelierung von Kurven und Flächen<a href="chapter_1/../links.html#a3">\(^{A3}\)</a>. Als Physiker bei Citroën arbeitete er ebenfalls an der Modellierung von Karosserien mithilfe von Bezierkurven. Unabhängig von Pierre Étienne Bézier entwickelte er den nach ihm benannten Casteljau Algorithmus zur Beschreibung von Bezierkurven.</p>
<p>Beide entwickelten das Konzept unabhängig voneinander, wobei der Name der Bezierkurve sich durchsetzte. Wohingegen der nach Casteljau benannte Algorithmus die bekannteste Darstellungsform ist.</p>
<p>Eine Bezierkurve wird durch mindestens zwei sogenannte Kontrollpunkte (sowohl 2-dimensional als auch 3-dimensional) beschrieben, welche den Verlauf der Kurve beeinflussen. Die Kontrollpunkte benannt \(P_{0}\) bis \(P_{n}\), wobei '\(n+1\)' den Grad der Kurve angibt. Der erste und letzte Kontrollpunkt sind die Endpunkte der Kurve und berühren diese somit, alle weiteren Kontrollpunkte \(P_{1} - P_{n-1}\), soweit vorhanden beeinflussen den Verlauf der Kurve, liegen aber, in der Regel nicht auf dieser.</p>
<p><img src="chapter_1/../img/Grad4Bezierkurve.png" alt="BezierkurveGrad4" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 1.1.1 Bezierkurve mit 4 Kontrollpunkten (BezierkurveGrad4)</P>
<p>Mathematisch wird die Kurve \(B\) in Abhängigkeit von \( t \) als \(B(t)\) angegeben, wobei \( 0\leq{}t\leq{}1 \) ist. Und es gilt \( B(0)=P_{0} \) und \( B(1)=P_{n} \). Bei \( n \) Kontrollpunkten gilt somit<a href="chapter_1/../links.html#a13">\(^{A13}\)</a>: </p>
<p>$$ B(t) = \sum_{i=0}^{n}{^nC_{i} (1-t)^{n-i} t^i P_{i}} , 0 \leq t \leq 1 $$</p>
<p>Oder auch:</p>
<p>$$ B(t) = \sum_{i=0}^{n}{\frac{n!}{i! (n - i)!} (1-t)^{n-i} t^i P_{i}} , 0 \leq t \leq 1$$</p>
<p>Hier lässt sich das vorangegangene Verhalten gut erkennen bei kleinem \( t \) setzt sich \( P_{0} \) durch und bei großem \( t \) setzt sich \( P_{n} \) durch.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="11-was-sind-bezierkurven-1"><a class="header" href="#11-was-sind-bezierkurven-1">1.1 Was sind Bezierkurven</a></h3>
<p>Der französische Ingenieur Pierre Étienne Bézier<a href="chapter_1/../links.html#a1">\(^{A1}\)</a>, geboren 1910 in Paris, entwickelte in den 60er Jahren eine Gestaltungsmöglichkeit von Karosserieformen für seinen damaligen Arbeitgeber Renault. Seit 1968 ist sein System zur &quot;Freiform Kurven und Oberflächen Design&quot; (&quot;interactive free-form curve and surface design and 3D milling for manufactoring clay models and masters&quot;<a href="chapter_1/../links.html#a2">\(^{A2}\)</a>) bei Renault in Nutzung.</p>
<p>Auch der französische Mathematiker Paul de Faget de Casteljau, geboren 1930, beschäftigte sich im 20ten Jahrhundert mit der Modelierung von Kurven und Flächen<a href="chapter_1/../links.html#a3">\(^{A3}\)</a>. Als Physiker bei Citroën arbeitete er ebenfalls an der Modellierung von Karosserien mithilfe von Bezierkurven. Unabhängig von Pierre Étienne Bézier entwickelte er den nach ihm benannten Casteljau Algorithmus zur Beschreibung von Bezierkurven.</p>
<p>Beide entwickelten das Konzept unabhängig voneinander, wobei der Name der Bezierkurve sich durchsetzte. Wohingegen der nach Casteljau benannte Algorithmus die bekannteste Darstellungsform ist.</p>
<p>Eine Bezierkurve wird durch mindestens zwei sogenannte Kontrollpunkte (sowohl 2-dimensional als auch 3-dimensional) beschrieben, welche den Verlauf der Kurve beeinflussen. Die Kontrollpunkte benannt \(P_{0}\) bis \(P_{n}\), wobei '\(n+1\)' den Grad der Kurve angibt. Der erste und letzte Kontrollpunkt sind die Endpunkte der Kurve und berühren diese somit, alle weiteren Kontrollpunkte \(P_{1} - P_{n-1}\), soweit vorhanden beeinflussen den Verlauf der Kurve, liegen aber, in der Regel nicht auf dieser.</p>
<p><img src="chapter_1/../img/Grad4Bezierkurve.png" alt="BezierkurveGrad4" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 1.1.1 Bezierkurve mit 4 Kontrollpunkten (BezierkurveGrad4)</P>
<p>Mathematisch wird die Kurve \(B\) in Abhängigkeit von \( t \) als \(B(t)\) angegeben, wobei \( 0\leq{}t\leq{}1 \) ist. Und es gilt \( B(0)=P_{0} \) und \( B(1)=P_{n} \). Bei \( n \) Kontrollpunkten gilt somit<a href="chapter_1/../links.html#a13">\(^{A13}\)</a>: </p>
<p>$$ B(t) = \sum_{i=0}^{n}{^nC_{i} (1-t)^{n-i} t^i P_{i}} , 0 \leq t \leq 1 $$</p>
<p>Oder auch:</p>
<p>$$ B(t) = \sum_{i=0}^{n}{\frac{n!}{i! (n - i)!} (1-t)^{n-i} t^i P_{i}} , 0 \leq t \leq 1$$</p>
<p>Hier lässt sich das vorangegangene Verhalten gut erkennen bei kleinem \( t \) setzt sich \( P_{0} \) durch und bei großem \( t \) setzt sich \( P_{n} \) durch.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="12-wo-findet-man-bezierkurven"><a class="header" href="#12-wo-findet-man-bezierkurven">1.2 Wo findet man Bezierkurven</a></h3>
<p>Heutzutage sind Bezierkurven in vielen Bereichen zu finden. Insbesondere in der Softwareindustrie stolpert man an jeder Ecke über die Verwendung von Bezierkurven.</p>
<p>Viele Bildbearbeitungsprogramme nutzen Bezierkurven um Farbkorrekturen zu ermöglichen oder um Kurven einzufügen. <br />
In Gimp<a href="chapter_1/../links.html#a4">\(^{A4}\)</a> zum Beispiel lassen sich die einzelnen Farbkanäle, Rot, Grün, Blau und Alpha/Transparenz mithilfe einer Bezierkurve anpassen. </p>
<p><img src="chapter_1/../img/FarbkurvenkorrekturfensterGimp.png" alt="Farbkurveneditor Gimp" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 1.2.1 Farbkurveneditor Gimp</p>
<p>Aber auch in Programmen wie Paint.NET<a href="chapter_1/../links.html#a5">\(^{A5}\)</a> gibt es Tools, die einem Erlauben mit Hilfe von Bezierkurven Grafiken zu erstellen. Durch das Bewegen von zwei Konrollpunkten lässt sich eine Kurve erstellen, welche von einem Punkt zum anderen verläuft und durch weitere Kontrollpunkte beeinflusst wird.</p>
<p><img src="chapter_1/../img/BezierkurventoolPaintNet.png" alt="Bezierkurve in Paint.NET" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 1.2.2 Bezierkurve in Paint.NET</p>
<p>Beim Erstellen von Animationen und dem Beschreiben von Bewegungen werden Bezierkurven genutzt um flüssige Bewegungsabläufe und Übergänge zu erstellen, wie zum Beispiel im Animtionseditor der Spieleengine Unity<a href="chapter_1/../links.html#a14">\(^{A14}\)</a>.</p>
<p><img src="chapter_1/../img/AnimationCurveSnakeVid.png" alt="Animierte Schlange in Unity" /></p>
<p style="text-align: center; font-size: 1.6rem;">Animation 1.2.3 Animierte Schlange in Unity</p>
<p>Auch viele Mindmap oder Graphing Tools nutzen Bezierkurven um Beziehungen zwischen Elementen kenntlich zu machen. Wie auch in diesem Bild aus einem von mir erstellten Nachbau des Lehrprogramms LogikSim<a href="chapter_1/../links.html#a6">\(^{A6}\)</a>, mit Hilfe dessen man Stromschaltkreise simulieren kann.</p>
<p><img src="chapter_1/../img/LogicSimulatorBezierConnectors.png" alt="LogikSim Clone" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 1.2.4 LogikSim Clone{A7}</p>
<p>Das kürzlich im Informatikunterricht entstandene Softwareprojekt zur Effizienzoptimierung von Bahnverbindungen und Zugstrecken nutzt Bezierkurven um den Verlauf der Schienen darzustellen<a href="chapter_1/../links.html#a15">\(^{A15}\)</a>.</p>
<p><img src="chapter_1/../img/RailwayDemoBezierTracks.png" alt="Railway Informatikprojekt" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 1.2.5 Railway Informatikprojekt</p>
<p>Was viele nicht wissen, auch bei Schriftarten kommen Bezierkurven zum Einsatz. <br />
Dateiformate wie zum Beispiel TrueType<a href="chapter_1/../links.html#a8">\(^{A8}\)</a> oder OpenType<a href="chapter_1/../links.html#a9">\(^{A9}\)</a> nutzen Bezierkurven um die Umrandung (outline) einzelner Buchstaben mathematisch zu beschreiben. Dies verhindert, dass die Buchstaben bei Änderung der Schriftgröße nicht unscharf oder verschwommen werden. Auf Abruf kann für jede Schriftgröße vom entsprechenden Programm zur Laufzeit das passende Bild der Buchstaben generiert werden. Dieses Verfahren wird Fontrasterization gennant<a href="chapter_1/../links.html#a10">\(^{A10}\)</a>.</p>
<p><img src="https://docs.microsoft.com/en-us/typography/truetype/images/rast-image27.gif" alt="Font Rasterization" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 1.2.6 Font Rasterization</p>
<p>Bild<a href="chapter_1/../links.html#a11">\(^{A11}\)</a></p>
<style>
    img{
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
</style><div style="break-before: page; page-break-before: always;"></div><h2 id="2-zeichnen-von-bezierkurven-1"><a class="header" href="#2-zeichnen-von-bezierkurven-1">2. Zeichnen von Bezierkurven</a></h2>
<p>Wir haben gesehen, dass Bezierkurven in vielen Bereichen Anwendung finden und jeder von uns sie schon einmal verwendet hat, auch wenn es nur durch das Schreiben eines Textes in Microsoft Word<a href="../links.html#a16">\(^{A16}\)</a> war. <br />
Nun wollen wir jedoch nicht mehr anschauen, wo wir Bezierkurven finden, sondern wir wollen selber Bezierkurven zeichnen. Vorerst wollen wir uns hierzu mit dem De Casteljau's Algorithmus beschäftigen.</p>
<h3 id="21-nutzung-des-de-casteljaus-algorithmus"><a class="header" href="#21-nutzung-des-de-casteljaus-algorithmus">2.1 Nutzung des De Casteljau's Algorithmus</a></h3>
<p>Der nach Paul de Casteljau benannte Algorithmus, ist ein rekursiver Algorithmus zur näherungsweisen Auswertung von Bezierkurven, mithilfe linearer Interpolation. Welche durch theoretische unendliche Verfeinerung die Bezierkurve formt.</p>
<blockquote>
<p>Linear interpolation is the simplest method of getting values at positions in between the data points. The points are simply joined by straight line segments. Each segment (bounded by two data points) can be interpolated independently. The parameter mu defines where to estimate the value on the interpolated line, it is 0 at the first point and 1 and the second point. For interpolated values between the two points mu ranges between 0 and 1. Values of mu outside this range result in extrapolation. <br />
-- Paul Bourke<a href="../links.html#a12">\(^{A12}\)</a></p>
</blockquote>
<h4 id="211-beispiel-mit-zwei-kontrollpunkten"><a class="header" href="#211-beispiel-mit-zwei-kontrollpunkten">2.1.1 Beispiel mit zwei Kontrollpunkten</a></h4>
<p>Zur Interpolation zweier Zahlen wird folgende Funktion genutzt:
$$ lerp(a,b,t) = (1-t)*a + t * b, 0 \leq t \leq 1 $$</p>
<p>Und eingesetzt:</p>
<p>$$ lerp(t) = (1-t)*P_{0} + t * P_{1} $$</p>
<p>Schauen wir uns nun die Bezierfunktion mit zwei Kontrollpunkten an:
$$B(t) = \sum_{i=0}^{n} \frac{n!}{i! (n - i)!} (1-t)^{n-i} t^i P_{i} $$</p>
<p>$$ B_{2}(t) = \sum_{i=0}^{1} \frac{1!}{i! (1 - i)!} (1-t)^{1-i} t^i P_{i} = [\frac{1!}{0! (1 - 0)!} (1-t)^{1-0} t^0 P_{0}] + [\frac{1!}{1! (1 - 1)!} (1-t)^{1-1} t^1 P_{1}] $$
$$ = [(1-t)P_{0}] + [tP_{1}] = (1-t)P_{0} + t*P_{1} $$</p>
<p>Also ist eine Bezierkurve des zweiten Grades gleich einer linearen Interpolation.</p>
<p><img src="./img/LinearBezierAnimatedT.png" alt="Lineare Bezierkurve abhängig von t" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 2.1.1 Lineare Bezierkurve abhängig von t (LinearBezierAnimatedT)</p>
<p>Es lässt sich erkennen, dass der blaue Punkt von \(P_{0}\) bei \(t=0\) zu \(P_{1}\) bei \(t=1\) wandert.
Also lässt sich eine lineare Bezierkurve zeichnen, indem man kleine Intervalle von \(t\) berechnet und verbindet:</p>
<pre><code class="language-cs">void drawLinearBezier(){
    var step = 0.01;
    var t = 0;
    while(t &lt;= 1){
        line(lerp(P0,P1,t), lerp(P0,P1,t+step));
        t += step;
    }
}

void line(Point p0, Point p1); // Implementation not included
Point lerp(Point a, Point b, float t); // Implementation not included 
</code></pre>
<p>Und sich so durch einen immer kleineren &quot;step&quot; der Originalkurve annähert.</p>
<h4 id="212-beispiel-mit-drei-kontrollpunkten"><a class="header" href="#212-beispiel-mit-drei-kontrollpunkten">2.1.2 Beispiel mit drei Kontrollpunkten</a></h4>
<p>Um nun eine Bezierkurve mit mehr als zwei Kontrollpunkten zu zeichnen, gehen wir nach dem gleichen Verfahren vor, nur dass wir diesmal zwischen drei Punkten interpolieren müssen. Dies lässt sich wie folgt verwirklichen:</p>
<p>$$ lerp3(a,b,c,t) = lerp(\color{yellow}{lerp(a,b,t)},\color{red}{lerp(b,c,t)},t) $$</p>
<p>Oder mit Punkten:</p>
<p>$$ lerp3(t) = lerp(\color{yellow}{lerp(P_{0},P_{1},t)},\color{red}{lerp(P_{1},P_{2},t)},t) $$</p>
<p>Was man ausschreiben kann als:</p>
<p>$$ lerp3(t) = (1-t)\color{yellow}{((1-t)P_{0} + tP_{1})} + t\color{red}{((1-t)P_{1} + tP_{2})} $$</p>
<p>Veranschaulicht gibt dies folgenden Verlauf:</p>
<p><img src="./img/QuadraticBezierAnimatedT.png" alt="ezierkurve mit drei Kontrollpunkten abhängig von t" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 2.1.2 Bezierkurve mit drei Kontrollpunkten abhängig von t (QuadraticBezierAnimatedT)</p>
<p>Das zeigt sich auch in der allgemeinen Form des Grades drei:</p>
<p>$$ B_{3}(t) = \sum_{i=0}^{2} \frac{2!}{i! (2 - i)!} (1-t)^{2-i} t^i P_{i} $$</p>
<p>$$ = [\frac{2!}{0! (2 - 0)!} (1-t)^{2-0} t^0 P_{0}] + [\frac{2!}{1! (2 - 1)!} (1-t)^{2-1} t^1 P_{1}] + [\frac{2!}{2! (2 - 2)!} (1-t)^{2-2} t^2 P_{2}]$$</p>
<p>$$ = (1-t)^2P_{0} + 2(1-t)tP_{1} + t^2P_{2} $$</p>
<p>$$ = (1-t)^2P_{0} + (1-t)tP_{1} + (1-t)tP_{1} + t^2P_{2} $$</p>
<p>$$ = (1-t)((1-t)P_{0} + tP_{1} ) + (1-t)tP_{1} + t^2P_{2} $$</p>
<p>$$ = (1-t) \color{yellow}{((1-t)P_{0} + tP_{1} )} + t\color{red}{((1-t)P_{1} + tP_{2})} $$ </p>
<p>Das an zwei und drei Kontrollpunkten gezeigte Verhalten gilt auch bei unendlich vielen Kontrollpunkten.</p>
<p>So lässt bei Variation des t eine beliebig genaue Annäherung an die Bezierkurve bestimmen.</p>
<p><img src="./img/QuadraticBezierChangingT.png" alt="Bezierkurve mit drei Kontrollpunkten und großem Δt" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 2.1.3 Bezierkurve mit drei Kontrollpunkten und großem Δt (QuadraticBezierChangingT)</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="31-anwendung"><a class="header" href="#31-anwendung">3.1 Anwendung</a></h3>
<p>Wie schon bereits in <a href="chapter_3/../chapter_1/WoFindetManBezierkurven.html">1.2</a> beschrieben, nutzt das Schulprojekt Railway aus dem Informatikprojekt Bezierkurven um Kurven in Bahnlinien zu erstellen darzustellen. Hierzu wird je nach Type (Kurve oder Versatz) eine Bezierkurve dritten oder vierten Grades erstellt. </p>
<p><img src="chapter_3/../img/RailwayBezierPoints.png" alt="Bezierkurve 3ten und 4ten Grades in Railway" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.1.1 Bezierkurven Grad 3 und 4 in Railway</p>
<p>Railway<a href="chapter_3/../links.html#a15">\(^{A15}\)</a></p>
<p>Die Strecke wird durch festgelegte Punkte am Anfang und am Ende eines Bahnsegments angegeben. Die weiteren ein bzw. zwei Kontrollpunkte werden vom Programm entsprechend der bereits bekannten Punkte ermittelt.</p>
<p>Wenn zur Laufzeit des Programmes ein neues Kurvenelement erzeugt werden soll, werden diese Punkte dem Element übergeben.</p>
<pre><code class="language-java">public CurveForm(
    int x1, int y1, 
    int x2, int y2, 
    int x3, int y3, 
    float width, 
    Color color) {
        // Weiterer Initlialisierungs Code
    }
</code></pre>
<p>Anschließend werden mit Hilfe des De Casteljau Algorithmus 100 Punkte auf der Kurve berechnet und mit Linien verbunden, welche statisch an die Grafikkarte gesendet werden, um dort zum Rendern benutzt zu werden.</p>
<pre><code class="language-java">origin_x = new float[(int) density];
origin_y = new float[(int) density];
for (int i = 0; i &lt; density; i++) {
    float t = i/(density * 1.0f); // Berechne t für die i-te Iteration
    origin_x[i] = (1 - t)*(1 - t) * x1 + 2*t*(1-t)*x2 + (t*t) * x3; 
    origin_y[i] = (1 - t)*(1 - t) * y1 + 2*t*(1-t)*y2 + (t*t) * y3;
    // Zwischenspeichern der Punkte auf der Kurve
}

//Befüllen des Vertexarrays mit den berechneten Punkten der Linien
vertexArray = new float[density * 7 * 2];
int index = 0;
int point = 0;

//Breite der Linie durch Verschiebung der Punkte
float upper_rad1 = (float) (Math.atan2(y2- y1, x2 - x1 ) - (Math.PI / 20f));
float lower_rad1 = (float) (Math.atan2(y2- y1, x2 - x1 ) + (Math.PI / 20f));
vertexArray[index    ] = origin_x[point] + Math.cos(lower_rad1) * width;
vertexArray[index + 1] = origin_y[point] + Math.sin(lower_rad1) * width;
//[misc]
index += 7;
vertexArray[index    ] = origin_x[point] + Math.cos(upper_rad1) * width;
vertexArray[index + 1] = origin_y[point] + Math.sin(upper_rad1) * width;
//[misc]
index += 7;
point++;
for (int i = 0; i &lt; density - 2; i++) {
    float y_dist = origin_y[point] - origin_y[point - 1];
    float x_dist = origin_x[point] - origin_x[point - 1];
    float ru = (float) (Math.atan2(y_dist, x_dist) - (Math.PI / 2.0f));
    float rl = (float) (Math.atan2(y_dist, x_dist) + (Math.PI / 2.0f));
    vertexArray[index    ] = origin_x[point] + Math.cos(rl) * width;
    vertexArray[index + 1] = origin_y[point] + Math.sin(rl) * width;
    //[misc]
    index += 7;
    vertexArray[index    ] = origin_x[point] + Math.cos(ru) * width;
    vertexArray[index + 1] = origin_y[point] + Math.sin(ru) * width;
    //[misc]
    index += 7;
    point++;
}
float upper_rad2 = (float) (Math.atan2(y3- y2, x3 - x2 ) - (Math.PI / 20f));
float lower_rad2 = (float) (Math.atan2(y3- y2, x3 - x2 ) + (Math.PI / 20f));
vertexArray[index    ] = origin_x[point] + Math.cos(lower_rad2) * (width/ 2.0f);
vertexArray[index + 1] = origin_y[point] + Math.sin(lower_rad2) * (width/ 2.0f);
//[misc]
index += 7;
vertexArray[index    ] = origin_x[point] + Math.cos(upper_rad2) * (width/ 2.0f);
vertexArray[index + 1] = origin_y[point] + Math.sin(upper_rad2) * (width/ 2.0f);
//[misc]

// Element Array Generation
</code></pre>
<p>Diese einzelnen Linien können nun mit einer simplen Kombination aus fragment und vertex Shader auf dem Bildschirm angezeigt werden.</p>
<pre><code class="language-cpp">#type vertex
#version 330 core
layout (location=0) in vec3 aPos;
layout (location=1) in vec4 aColor;

uniform mat4 uProj;
uniform mat4 uView;

out vec4 fColor;

void main(){
    fColor = aColor;
    vec4 pos = uProj * uView * vec4(aPos, 1);
    gl_Position = pos;
}

#type fragment
#version 330 core

in vec4 fColor;

out vec4 color;

void main(){
    color = fColor;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="31-anwendung-1"><a class="header" href="#31-anwendung-1">3.1 Anwendung</a></h3>
<p>Wie schon bereits in <a href="chapter_3/../chapter_1/WoFindetManBezierkurven.html">1.2</a> beschrieben, nutzt das Schulprojekt Railway aus dem Informatikprojekt Bezierkurven um Kurven in Bahnlinien zu erstellen darzustellen. Hierzu wird je nach Type (Kurve oder Versatz) eine Bezierkurve dritten oder vierten Grades erstellt. </p>
<p><img src="chapter_3/../img/RailwayBezierPoints.png" alt="Bezierkurve 3ten und 4ten Grades in Railway" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.1.1 Bezierkurven Grad 3 und 4 in Railway</p>
<p>Railway<a href="chapter_3/../links.html#a15">\(^{A15}\)</a></p>
<p>Die Strecke wird durch festgelegte Punkte am Anfang und am Ende eines Bahnsegments angegeben. Die weiteren ein bzw. zwei Kontrollpunkte werden vom Programm entsprechend der bereits bekannten Punkte ermittelt.</p>
<p>Wenn zur Laufzeit des Programmes ein neues Kurvenelement erzeugt werden soll, werden diese Punkte dem Element übergeben.</p>
<pre><code class="language-java">public CurveForm(
    int x1, int y1, 
    int x2, int y2, 
    int x3, int y3, 
    float width, 
    Color color) {
        // Weiterer Initlialisierungs Code
    }
</code></pre>
<p>Anschließend werden mit Hilfe des De Casteljau Algorithmus 100 Punkte auf der Kurve berechnet und mit Linien verbunden, welche statisch an die Grafikkarte gesendet werden, um dort zum Rendern benutzt zu werden.</p>
<pre><code class="language-java">origin_x = new float[(int) density];
origin_y = new float[(int) density];
for (int i = 0; i &lt; density; i++) {
    float t = i/(density * 1.0f); // Berechne t für die i-te Iteration
    origin_x[i] = (1 - t)*(1 - t) * x1 + 2*t*(1-t)*x2 + (t*t) * x3; 
    origin_y[i] = (1 - t)*(1 - t) * y1 + 2*t*(1-t)*y2 + (t*t) * y3;
    // Zwischenspeichern der Punkte auf der Kurve
}

//Befüllen des Vertexarrays mit den berechneten Punkten der Linien
vertexArray = new float[density * 7 * 2];
int index = 0;
int point = 0;

//Breite der Linie durch Verschiebung der Punkte
float upper_rad1 = (float) (Math.atan2(y2- y1, x2 - x1 ) - (Math.PI / 20f));
float lower_rad1 = (float) (Math.atan2(y2- y1, x2 - x1 ) + (Math.PI / 20f));
vertexArray[index    ] = origin_x[point] + Math.cos(lower_rad1) * width;
vertexArray[index + 1] = origin_y[point] + Math.sin(lower_rad1) * width;
//[misc]
index += 7;
vertexArray[index    ] = origin_x[point] + Math.cos(upper_rad1) * width;
vertexArray[index + 1] = origin_y[point] + Math.sin(upper_rad1) * width;
//[misc]
index += 7;
point++;
for (int i = 0; i &lt; density - 2; i++) {
    float y_dist = origin_y[point] - origin_y[point - 1];
    float x_dist = origin_x[point] - origin_x[point - 1];
    float ru = (float) (Math.atan2(y_dist, x_dist) - (Math.PI / 2.0f));
    float rl = (float) (Math.atan2(y_dist, x_dist) + (Math.PI / 2.0f));
    vertexArray[index    ] = origin_x[point] + Math.cos(rl) * width;
    vertexArray[index + 1] = origin_y[point] + Math.sin(rl) * width;
    //[misc]
    index += 7;
    vertexArray[index    ] = origin_x[point] + Math.cos(ru) * width;
    vertexArray[index + 1] = origin_y[point] + Math.sin(ru) * width;
    //[misc]
    index += 7;
    point++;
}
float upper_rad2 = (float) (Math.atan2(y3- y2, x3 - x2 ) - (Math.PI / 20f));
float lower_rad2 = (float) (Math.atan2(y3- y2, x3 - x2 ) + (Math.PI / 20f));
vertexArray[index    ] = origin_x[point] + Math.cos(lower_rad2) * (width/ 2.0f);
vertexArray[index + 1] = origin_y[point] + Math.sin(lower_rad2) * (width/ 2.0f);
//[misc]
index += 7;
vertexArray[index    ] = origin_x[point] + Math.cos(upper_rad2) * (width/ 2.0f);
vertexArray[index + 1] = origin_y[point] + Math.sin(upper_rad2) * (width/ 2.0f);
//[misc]

// Element Array Generation
</code></pre>
<p>Diese einzelnen Linien können nun mit einer simplen Kombination aus fragment und vertex Shader auf dem Bildschirm angezeigt werden.</p>
<pre><code class="language-cpp">#type vertex
#version 330 core
layout (location=0) in vec3 aPos;
layout (location=1) in vec4 aColor;

uniform mat4 uProj;
uniform mat4 uView;

out vec4 fColor;

void main(){
    fColor = aColor;
    vec4 pos = uProj * uView * vec4(aPos, 1);
    gl_Position = pos;
}

#type fragment
#version 330 core

in vec4 fColor;

out vec4 color;

void main(){
    color = fColor;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="32-ineffizienz-und-schwierigkeiten-in-der-praxis"><a class="header" href="#32-ineffizienz-und-schwierigkeiten-in-der-praxis">3.2 Ineffizienz und Schwierigkeiten in der Praxis</a></h3>
<p>Beim vorangegangenen Ansatz aus <a href="chapter_3/./Anwendung.html">3.1</a> wird die gesamte Arbeit der Bestimmung der Bezierkurve auf Seiten der CPU im vornerein berechnet und die Grafikkarte ausgehebelt, indem nur noch Linien gezeichnet werden. Dieses Vorgehen ist ungenau, da der Casteljau Algorithmus nur eine Annäherung der Kurve berechnet. Dies zeigt sich insbesondere an den Ecken der Kurven, welche auf Grund der ungleichen Verteilung der von \(t\) abhängigen Punkte auf der Kurve sehr harte Stufenübergänge erhalten. </p>
<p><img src="chapter_3/../img/RailwayEdgeDistortion.png" alt="Ecken ungenauigkeit bei Bezierkurven" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.2.1 Ecken Ungenauigkeit bei Bezierkurven</p>
<p>Auch die Verwendung von Antialiasing<a href="chapter_3/../links.html#a17">\(^{A17}\)</a>, um diese Ungenauigkeiten zu verblenden, ist aufgrund des Entstehen von Überlappung der Linien nur unter hohem Aufwand möglich. </p>
<p>Ein möglicher Lösungsansatz wäre es, die Berechnung der Kurve auf die GPU zu verlagern und dort nach dem De Casteljau Algorithmus für verschiedene \(t\) die Nähe des gerade zu berechnenden Pixels zu ermitteln, um so die Kurve darzustellen. Dies hätte den Vorteil, dass man auch im Nachhinein noch die Position der Kontrollpunkte verändern könnte, sowie basierend auf der Nähe zum berechneten \(t\) auch eine Form des Antialiasing anwenden könnte um harte Übergänge zu vermeiden.</p>
<pre><code class="language-cpp">#type fragment
#version 330 core

#define STEP 100.0
//Thickness
#define DIST 0.1

in vec2 pixelCoord;
out vec4 pixelColor;

vec3 colorBezier(vec2 pixelCoord, vec2 pos1, vec2 pos2, vec2 pos3, vec3 baseColor, vec3 bezierColor){
    vec3 color = baseColor;

    // De Casteljau Algorithmus
    for (float st = 0.; st &lt;= STEP; st++){
        float t = st*1./STEP;
        vec2 pos = (pos1.xy - 2. * pos2.xy + pos3.xy) * t*t;
        pos += (-2.*pos1.xy + 2.* pos2.xy)*t +
        pos1.xy;
        float dist = distance(pixelCoord.xy / 100., pos.xy / 100.);
        if (dist &lt; DIST){
            color = bezierColor;
        }
    }
    return color;
}
vec3 pointDraw(vec2 pixelCoord, vec2 pos, vec3 baseColor, vec3 pointColor){...}//SDFCircleFunc
void main()
{
    vec3 col = vec3(0, 0, 0);
    vec3 colorP1 = vec3(1, 0, 0);
    vec2 posP1 = vec2(200, 100);
    vec3 colorP2 = vec3(0, 1, 0);
    vec2 posP2 = vec2(200, 300);
    vec3 colorP3 = vec3(0, 0, 1);
    vec2 posP3 = vec2(400, 200);
    col = colorBezier(pixelCoord, posP1, posP2, posP3, col, vec3(1, 1, 1));
    col = pointDraw(pixelCoord, posP1, col, colorP1);
    col = pointDraw(pixelCoord, posP2, col, colorP2);
    col = pointDraw(pixelCoord, posP3, col, colorP3);

    pixelColor = vec4(col, 1.0);
}
</code></pre>
<p>Bei näherer Betrachtung dieser Methode unter Berücksichtigung der Funktionsweise moderner Grafikkarten und dem damit einhergehenden Leitfaden zur Vermeidung von Kontrollstrukturen und Iteration sowie Rekursion und der größtmöglichen Beschränkung auf mathematische Rechnungen, zeigt sich auch in der Praxis, dass der hier gewählte Ansatz schon bei einzelnen Kurven eine erhebliche Menge an Rechenleistung benötigt und schon bei wenigen Kurven pro Frame nicht mehr realistisch verwendbar ist. Auch bleibt die Ungenauigkeit des De Casteljau Algorithmus erhalten.</p>
<p>Ein realistischer Lösungsansatz zur exakten Berechnung und Zeichnung von Bezierkurven soll im Folgenden erarbeitet werden. <br />
Um dies zu erzielen, soll durch das Lösen von Funktionsgleichungen die Bestimmung, ob ein Pixel \(P\) auf \(B(t)\) liegt, mathematisch und ohne rekursiven Aufruf erfolgen, um so die Grafikkarte optimal zu nutzen und effizient eine vielzahl verschiedener Bezierkurven zu zeichnen.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="33-mathematischer-lösungsansatz"><a class="header" href="#33-mathematischer-lösungsansatz">3.3 Mathematischer Lösungsansatz</a></h3>
<p>Der mathematische Lösungsweg wird im Folgenden für eine beliebige Bezierkurve dritten Grades gezeigt. Die meisten der gezeigten Eigenschaften lassen sich jedoch auf Bezierkurven mit anderem Grad übertragen.</p>
<p>Als Ausgangsgleichung ziehen wir also die zuvor in <a href="chapter_3/../chapter_2.html">2.1.2</a> hergeleitete Gleichung:</p>
<p>$$ B_{3}(t) = (1-t)^2P_{0} + 2(1-t)tP_{1} + t^2P_{2} $$</p>
<p>Da \(P_{0}\) - \(P_{2}\) Punkte mit jeweils einer \(x\) und \(y\) sind lässt sich die obige Gleichung unterteilen in eine für \(x\) und eine für \(y\):</p>
<p>$$ B_{x3}(t) = (1-t)^2x_{0} + 2(1-t)tx_{1} + t^2x_{2} $$
$$ B_{y3}(t) = (1-t)^2y_{0} + 2(1-t)ty_{1} + t^2y_{2} $$</p>
<p>Nehmen wir Besipielsweise die Punkte \(P_{0} = (2,1), P_{1} = (3,3), P_{2} = (5,2) \), so sieht die dazugehörige Bezierkurve wie folgt aus:</p>
<p><img src="chapter_3/./../img/MathematischerAnsatzBeispielkurveRaw.png" alt="Bezierkurve mit Fixen Punkten" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.3.1 Bezierkurve mit festen Punkten</p>
<p>Die dazugehörigen Graphen von \(x\) und \(y\) sind:</p>
<p><img src="chapter_3/../img/MathematischerAnsatzBeispielkurveRawEinzelgleichungen.png" alt="Bezierkurve Einzelgleichungen" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.3.2 Einzelgleichungen der Bezierkurve; x oben, y unten</p>
<p>Bei genauerer Betrachtung einzelner Punkte bzw. einzelner \(t\),  lässt sich erkennen, dass alle Punkte auf \(B_{3}(t)\), die gleiche \(x\) Koordinate in den Einzelgleichungen haben, und somit untereinander liegen.</p>
<p><img src="chapter_3/../img/MathematischerAnsatzBeispielkurveGleichesXF%C3%BCrWahrT.png" alt="Gleiche x Koordinate für t" /></p>
<p style="text-align: center; font-size: 1.6rem;">Bild 3.3.3 Gleiche x Koordinate für t auf der Bezierkurve</p>
<p>Setzen wir nun \(B(t) = T\), wobei \(T\) ein beliebiger Punkt ist, für den wir Testen ob er auf \(B(t)\) liegt, können wir die Gleichung wie folgt für \(t\) lösen:</p>
<p>$$ B(t) = (1-t)^2P_{0} + 2(1-t)tP_{1} + t^2P_{2} = T $$</p>
<p>$$ (1-t)^2P_{0} + 2(1-t)tP_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ (1-t)(1-t) P_{0} + 2(1-t)tP_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ (1-2t+t^2) P_{0} + 2(1-t)tP_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ P_{0}-2tP_{0}+P_{0}t^2 + 2(1-t)tP_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ P_{0}-2tP_{0}+P_{0}t^2 + (2-2t)tP_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ P_{0}-2tP_{0}+P_{0}t^2 + (2t-2t^2)P_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ P_{0}-2tP_{0}+P_{0}t^2 + 2tP_{1}-2t^2P_{1} + t^2P_{2} - T = 0 $$</p>
<p>$$ P_{0} - T - 2tP_{0} + 2tP_{1} + P_{0}t^2 - 2t^2P_{1} + t^2P_{2}  = 0 $$</p>
<p>$$ P_{0} - T + 2tP_{1} - 2tP_{0} + P_{0}t^2 - 2t^2P_{1} + t^2P_{2}  = 0 $$</p>
<p>$$ P_{0} - T + t(2P_{1} - 2P_{0}) + t^2(P_{0} - 2P_{1} + P_{2})  = 0 $$</p>
<p>$$ t^2(P_{0} - 2P_{1} + P_{2}) + t(2P_{1} - 2P_{0}) + P_{0} - T +  = 0 $$</p>
<p>Mit Hilfe der Mitternachtsformel{A19} können wir nun die Gleichung, welche nun die Form \(a x^2 + b x + c = 0\) besitzt lösen:</p>
<p>$$ t_{1,2} = \frac{-(2P_{1} - 2P_{0}) \pm \sqrt{(2P_{1} - 2P_{0})^2 - 4(P_{0} - 2P_{1} + P_{2})(P_{0} - T)}}{2(P_{0} - 2P_{1} + P_{2})} $$</p>
<p>Für die \(x\) und \(y\) Komponente ergeben sich somit insgesamt zwischen 0 und 4 Lösungen \(\{t_{x1},t_{x2},t_{y1},t_{y2}\}\). 
Sind jetzt ein t von x und ein t von y gleich, so liegt \(T\) auf der Kurve. Die kleinste Differenz von x und y gibt also die Nähe des Punktes zur Kurve an.</p>
<p><img src="chapter_3/../img/MathematischerAnsatzBeispielkurveTestpunkt.png" alt="alt" /></p>
<p style="text-align: center; font-size: 1.6rem;">Demo 3.3.1 Testpunkt Nähe zur Kurve</p>
<style>
    img{
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
</style><div style="break-before: page; page-break-before: always;"></div><h3 id="4-zusammenfassung"><a class="header" href="#4-zusammenfassung">4. Zusammenfassung</a></h3>
<p>Bei der Betrachtung des de Casteljau Algorithmus und dessen Anwendung in der Praxis, wie in <a href="./chapter_3/IneffizienzUndSchwierigkeitenInDerPraxis.html">3.2</a> ist aufgefallen, dass der Algorithmus gerade für das Zeichnen solcher Bezierkurven aufgrund der Rekursivität, sowie Abhängigkeit von \(t\) in einem pixelbasierten rendering System ungeeignet ist.</p>
<p>Durch genauere Betrachtung der mathematischen Definition einer solchen Bezierkurve und das Nutzen der Mitternachtsformel konnte ich die folgende Formel wie in <a href="./chapter_3/MathematischerLoesungsansatz.html">3.3</a> herleiten, die nun punktspezifisch angewendet werden kann.</p>
<p>$$ t_{1,2} = \frac{-(2P_{1} - 2P_{0}) \pm \sqrt{(2P_{1} - 2P_{0})^2 - 4(P_{0} - 2P_{1} + P_{2})(P_{0} - T)}}{2(P_{0} - 2P_{1} + P_{2})} $$</p>
<p>Weiterführend zu dieser Arbeit kann nun die obige Formel genutzt werden, um die praktische Implementierung mithilfe eines Shaders durchzuführen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anhang"><a class="header" href="#anhang">Anhang</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h5 id="a1"><a class="header" href="#a1">A1</a></h5>
<p><a href="http://solidmodeling.org/awards/bezier-award/">http://solidmodeling.org/awards/bezier-award/</a> <br />
[05.03.2022 14:22]</p>
<h5 id="a2"><a class="header" href="#a2">A2</a></h5>
<p><a href="https://archive.ph/20120526012617/http://www.engology.com/eng5bezier.htm#selection-19.206-19.309">https://archive.ph/20120526012617/http://www.engology.com/eng5bezier.htm#selection-19.206-19.309</a> <br />
[05.03.2022 14:29]</p>
<h5 id="a3"><a class="header" href="#a3">A3</a></h5>
<p><a href="https://physik.cosmos-indirekt.de/Physik-Schule/Paul_de_Casteljau">https://physik.cosmos-indirekt.de/Physik-Schule/Paul_de_Casteljau</a> <br />
[05.03.2022 14:51]</p>
<h5 id="a4"><a class="header" href="#a4">A4</a></h5>
<p><a href="https://www.gimp.org/">https://www.gimp.org/</a> <br />
[05.03.2022 15:20]</p>
<h5 id="a5"><a class="header" href="#a5">A5</a></h5>
<p><a href="https://www.getpaint.net/">https://www.getpaint.net/</a> <br />
[05.03.2022 15:31]</p>
<h5 id="a6"><a class="header" href="#a6">A6</a></h5>
<p><a href="https://logiksim.dbclan.de/download.html">https://logiksim.dbclan.de/download.html</a> <br />
[06.03.2022 12:26]</p>
<h5 id="a7"><a class="header" href="#a7">A7</a></h5>
<p><a href="https://github.com/PixelboysTM/LogikSimClone">https://github.com/PixelboysTM/LogikSimClone</a> <br />
[06.03.2022 12:22]</p>
<h5 id="a8"><a class="header" href="#a8">A8</a></h5>
<p><a href="https://docs.microsoft.com/en-us/typography/truetype/">https://docs.microsoft.com/en-us/typography/truetype/</a> <br />
[06.03.2022 12:59]</p>
<h5 id="a9"><a class="header" href="#a9">A9</a></h5>
<p><a href="https://www.adobe.com/products/type/opentype.html">https://www.adobe.com/products/type/opentype.html</a> <br />
[06.03.2022 13:00]</p>
<h5 id="a10"><a class="header" href="#a10">A10</a></h5>
<p><a href="https://github.com/PixelboysTM/FacharbeitBezierkurven/blob/e3ed9e8ca87a5df89f1dd44b9265104c4cedf676/pdf/FontRasterizationRogerDHersch.pdf">https://github.com/PixelboysTM/FacharbeitBezierkurven/blob/e3ed9e8ca87a5df89f1dd44b9265104c4cedf676/pdf/FontRasterizationRogerDHersch.pdf</a> <br />
[20.04.2022 17:01]</p>
<h5 id="a11"><a class="header" href="#a11">A11</a></h5>
<p><a href="https://docs.microsoft.com/en-us/typography/truetype/images/rast-image27.gif">https://docs.microsoft.com/en-us/typography/truetype/images/rast-image27.gif</a> <br />
[06.03.2022 13:15]</p>
<h5 id="a12"><a class="header" href="#a12">A12</a></h5>
<p><a href="http://paulbourke.net/miscellaneous/interpolation/">http://paulbourke.net/miscellaneous/interpolation/</a> <br />
[06.03.2022 14:30]</p>
<h5 id="a13"><a class="header" href="#a13">A13</a></h5>
<p><a href="https://www.freecodecamp.org/news/nerding-out-with-bezier-curves-6e3c0bc48e2f/">https://www.freecodecamp.org/news/nerding-out-with-bezier-curves-6e3c0bc48e2f/</a> <br />
[13.03.2022 19:03]</p>
<h5 id="a14"><a class="header" href="#a14">A14</a></h5>
<p><a href="https://unity.com/">https://unity.com/</a> <br />
[13.03.2022 19:03]</p>
<h5 id="a15"><a class="header" href="#a15">A15</a></h5>
<p>Informatikprojekt EF/Q1</p>
<h5 id="a16"><a class="header" href="#a16">A16</a></h5>
<p><a href="https://www.microsoft.com/en-us/microsoft-365/word">https://www.microsoft.com/en-us/microsoft-365/word</a> <br />
[13.03.2022 19:19]</p>
<h5 id="a17"><a class="header" href="#a17">A17</a></h5>
<p><a href="https://helpx.adobe.com/photoshop-elements/key-concepts/aliasing-anti-aliasing.html">https://helpx.adobe.com/photoshop-elements/key-concepts/aliasing-anti-aliasing.html</a> <br />
[26.03.2022 11:19]</p>
<h5 id="a18"><a class="header" href="#a18">A18</a></h5>
<p><a href="https://www.desmos.com/calculator/4sabernbxy">https://www.desmos.com/calculator/4sabernbxy</a> <br />
[04.04.2022 17:32]</p>
<h5 id="a19"><a class="header" href="#a19">A19</a></h5>
<p><a href="https://de.serlo.org/mathe/1549/mitternachtsformel-quadratische-l%C3%B6sungsformel">https://de.serlo.org/mathe/1549/mitternachtsformel-quadratische-l%C3%B6sungsformel</a> <br />
[20.04.2022 12:05]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weitere-links"><a class="header" href="#weitere-links">Weitere Links</a></h1>
<p>L1 http://www.jeffreythompson.org/collision-detection/point-circle.php [12.03.2022 13:18]</p>
<p>https://cubic-bezier.com/#.58,1.35,.54,.33</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code"><a class="header" href="#code">Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="demos"><a class="header" href="#demos">Demos</a></h1>
<h2 id="bezierkurve-grad-4"><a class="header" href="#bezierkurve-grad-4">Bezierkurve Grad 4</a></h2>
<iframe style="width: 800px; height: 650px;" src="https://editor.p5js.org/PixelboysTM/full/b4gtDCf2N"></iframe>
<h2 id="linear-bezier-animated-t"><a class="header" href="#linear-bezier-animated-t">Linear Bezier Animated T</a></h2>
<iframe style="width: 800px; height: 650px;" src="https://editor.p5js.org/PixelboysTM/full/X_Zw5OJwp"></iframe>
<h2 id="quadratic-bezier-animated-t"><a class="header" href="#quadratic-bezier-animated-t">Quadratic Bezier Animated T</a></h2>
<iframe style="width: 800px; height: 650px;" src="https://editor.p5js.org/PixelboysTM/full/f4XuhuNiO"></iframe>
<h2 id="quadratic-bezier-changing-t"><a class="header" href="#quadratic-bezier-changing-t">Quadratic Bezier Changing T</a></h2>
<iframe style="width: 800px; height: 650px;" src="https://editor.p5js.org/PixelboysTM/full/f4tkbQQp0"></iframe>
<h2 id="testpunkt-nähe-zur-kurve"><a class="header" href="#testpunkt-nähe-zur-kurve">Testpunkt Nähe zur Kurve</a></h2>
<iframe style="width: 800px; height: 650px;" src="https://www.desmos.com/calculator/jw2lgqua3l?embed"></iframe>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
